module 0x1::CheerOrBooTests {
    use 0x1::CheerOrBoo;
    use std::vector;
    use std::bcs;
    use std::hash;

    #[test(sender = @0x1)]
    fun test_cheer_event(sender: signer) {
        let target = @0x2;
        let participants = generate_participants(100);
        let unique_identifier = b"CHEER_EVENT_TEST";

        // Use 0.00001 as the base unit; 1_000 corresponds to 0.01 units.
        CheerOrBoo::cheer_or_boo(
            &sender,
            target,
            participants,
            true,     // is_cheer
            1_000,    // amount (0.01 units)
            50,       // target_allocation (50%)
            unique_identifier
        );

        let emitted_events = 0x1::event::emitted_events<CheerOrBoo::CheerEvent>();
        assert!(vector::length(&emitted_events) == 1, 100);

        let cheer_event = vector::borrow(&emitted_events, 0);
        assert!(CheerOrBoo::cheer_get_target(cheer_event) == target, 101);
        assert!(CheerOrBoo::cheer_get_amount(cheer_event) == 1_000, 102); // Check amount in base unit
        assert!(CheerOrBoo::cheer_get_target_allocation(cheer_event) == 50, 103);
    }

    /// Generates `n` unique participant addresses deterministically.
    fun generate_participants(count: u64): vector<address> {
        generate_participants_internal(0, count, vector::empty<address>())
    }

    /// Internal recursive helper for participant generation.
    fun generate_participants_internal(index: u64, count: u64, participants: vector<address>): vector<address> {
        if (index >= count) {
            participants
        } else {
            let participant = generate_participant_address(index);
            let updated_participants = vector::push_back(participants, participant);
            generate_participants_internal(index + 1, count, updated_participants)
        }
    }

    /// Generates a deterministic participant address based on an index.
    fun generate_participant_address(index: u64): address {
        let base = b"BASE_PARTICIPANT_ADDRESS";
        let index_bytes = bcs::to_bytes(&index);
        let combined = append_bytes(base, index_bytes);
        let hash = hash::sha3_256(combined);
        assert!(vector::length(&hash) >= 32, 400); // Ensure valid length
        *vector::borrow(&hash, 0) // Use first 32 bytes as address
    }

    /// Concatenates two byte arrays immutably.
    fun append_bytes(b1: vector<u8>, b2: vector<u8>): vector<u8> {
        append_bytes_internal(b1, b2, 0, vector::empty<u8>())
    }

    /// Internal recursive helper for concatenation.
    fun append_bytes_internal(b1: vector<u8>, b2: vector<u8>, index: u64, combined: vector<u8>): vector<u8> {
        if (index < vector::length(&b1)) {
            let updated_combined = vector::push_back(combined, *vector::borrow(&b1, index));
            append_bytes_internal(b1, b2, index + 1, updated_combined)
        } else if (index - vector::length(&b1) < vector::length(&b2)) {
            let b2_index = index - vector::length(&b1);
            let updated_combined = vector::push_back(combined, *vector::borrow(&b2, b2_index));
            append_bytes_internal(b1, b2, index + 1, updated_combined)
        } else {
            combined
        }
    }
}
